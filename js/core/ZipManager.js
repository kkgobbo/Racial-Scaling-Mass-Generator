// ZIP file creation and management

class ZipManager {
    constructor() {
        this.zip = new JSZip();
        this.compressionLevel = 6; // Balance between size and speed
    }

    clear() {
        this.zip = new JSZip();
    }

    async addModToZip(modData) {
        try {
            const { folderName, metaJson, modJson } = modData;
            
            // Create folder in ZIP
            const folder = this.zip.folder(folderName);
            
            // Add files to folder
            folder.file('meta.json', metaJson);
            folder.file('default_mod.json', modJson);
            
            return true;
        } catch (error) {
            throw new Error(`Failed to add mod to ZIP: ${error.message}`);
        }
    }

    async generateIncrementally(mods, progressCallback) {
        try {
            // Clear any existing ZIP content
            this.clear();
            
            const total = mods.length;
            
            for (let i = 0; i < total; i++) {
                // Add mod to ZIP
                await this.addModToZip(mods[i]);
                
                // Update progress
                const progress = Math.round(((i + 1) / total) * 100);
                
                if (progressCallback) {
                    progressCallback({
                        percentage: progress,
                        current: i + 1,
                        total: total,
                        currentMod: mods[i].folderName
                    });
                }
                
                // Yield control back to UI thread to prevent blocking
                await this.sleep(0);
            }
            
            return true;
        } catch (error) {
            throw new Error(`Failed to generate ZIP incrementally: ${error.message}`);
        }
    }

    async generateZip(options = {}) {
        try {
            const {
                type = 'blob',
                compression = 'DEFLATE',
                compressionOptions = { level: this.compressionLevel }
            } = options;

            return await this.zip.generateAsync({
                type: type,
                compression: compression,
                compressionOptions: compressionOptions,
                comment: `Generated by FFXIV Height Mod Generator on ${new Date().toISOString()}`
            });
        } catch (error) {
            throw new Error(`Failed to generate ZIP file: ${error.message}`);
        }
    }

    async downloadZip(filename = 'Generated_Height_Mods.zip') {
        try {
            const blob = await this.generateZip();
            
            // Use FileSaver.js to trigger download
            if (typeof saveAs !== 'undefined') {
                saveAs(blob, filename);
            } else {
                // Fallback method
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            return true;
        } catch (error) {
            throw new Error(`Failed to download ZIP file: ${error.message}`);
        }
    }

    async getZipInfo() {
        try {
            const files = [];
            let totalSize = 0;
            
            this.zip.forEach((relativePath, file) => {
                if (!file.dir) {
                    files.push({
                        name: relativePath,
                        size: file._data ? file._data.uncompressedSize : 0
                    });
                    totalSize += file._data ? file._data.uncompressedSize : 0;
                }
            });
            
            return {
                fileCount: files.length,
                folderCount: Math.ceil(files.length / 2), // Assuming 2 files per folder
                totalSize: totalSize,
                files: files
            };
        } catch (error) {
            throw new Error(`Failed to get ZIP info: ${error.message}`);
        }
    }

    async validateZip() {
        try {
            const info = await this.getZipInfo();
            const errors = [];
            
            if (info.fileCount === 0) {
                errors.push("ZIP contains no files");
            }
            
            // Check for proper file structure (each folder should have meta.json and default_mod.json)
            const metaFiles = info.files.filter(f => f.name.endsWith('meta.json'));
            const modFiles = info.files.filter(f => f.name.endsWith('default_mod.json'));
            
            if (metaFiles.length !== modFiles.length) {
                errors.push("Inconsistent file structure - missing meta.json or default_mod.json files");
            }
            
            return {
                isValid: errors.length === 0,
                errors: errors,
                info: info
            };
        } catch (error) {
            return {
                isValid: false,
                errors: [`Validation failed: ${error.message}`],
                info: null
            };
        }
    }

    async estimateZipSize() {
        try {
            // Generate a small test ZIP to estimate compression ratio
            const testZip = new JSZip();
            const testData = JSON.stringify({test: "data"}, null, 2);
            testZip.file('test.json', testData);
            
            const testBlob = await testZip.generateAsync({
                type: 'blob',
                compression: 'DEFLATE',
                compressionOptions: { level: this.compressionLevel }
            });
            
            const compressionRatio = testBlob.size / testData.length;
            
            // Estimate size of current ZIP
            const info = await this.getZipInfo();
            const estimatedSize = Math.round(info.totalSize * compressionRatio);
            
            return {
                uncompressed: info.totalSize,
                estimated: estimatedSize,
                compressionRatio: compressionRatio
            };
        } catch (error) {
            throw new Error(`Failed to estimate ZIP size: ${error.message}`);
        }
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Advanced ZIP options
    setCompressionLevel(level) {
        if (level >= 0 && level <= 9) {
            this.compressionLevel = level;
        }
    }

    async addFileFromText(path, content, options = {}) {
        try {
            this.zip.file(path, content, options);
            return true;
        } catch (error) {
            throw new Error(`Failed to add file to ZIP: ${error.message}`);
        }
    }

    async addFolder(folderName) {
        try {
            this.zip.folder(folderName);
            return true;
        } catch (error) {
            throw new Error(`Failed to add folder to ZIP: ${error.message}`);
        }
    }

    getFolderList() {
        const folders = new Set();
        
        this.zip.forEach((relativePath, file) => {
            const pathParts = relativePath.split('/');
            if (pathParts.length > 1) {
                folders.add(pathParts[0]);
            }
        });
        
        return Array.from(folders);
    }
}